<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UVMDemo学习笔记(一个简单的UVM验证平台) | Later的个人博客 </title><meta name="author" content="Guanglong Zhao"><meta name="copyright" content="Guanglong Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UVMDemo学习笔记 UVM实战：一个简单的UVM验证平台   [TOC]  跑通Demo使用2.5.2的例子作为文件。需要对应自己的环境进行修改，修改如下。 1、setup.vcs修改 对应修改到bash shell下，参照~&#x2F;.bashrc修改即可，很简单。 对应修改VCS_HOME等自己实际的环境变量   bash和csh都是shell脚本语言。 Linux终端的核心组件是She">
<meta property="og:type" content="article">
<meta property="og:title" content="UVMDemo学习笔记(一个简单的UVM验证平台)">
<meta property="og:url" content="http://scfmvp.github.io/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Later的个人博客 ">
<meta property="og:description" content="UVMDemo学习笔记 UVM实战：一个简单的UVM验证平台   [TOC]  跑通Demo使用2.5.2的例子作为文件。需要对应自己的环境进行修改，修改如下。 1、setup.vcs修改 对应修改到bash shell下，参照~&#x2F;.bashrc修改即可，很简单。 对应修改VCS_HOME等自己实际的环境变量   bash和csh都是shell脚本语言。 Linux终端的核心组件是She">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://scfmvp.github.io/img/logo.jpg">
<meta property="article:published_time" content="2023-08-09T13:36:11.000Z">
<meta property="article:modified_time" content="2023-08-09T13:52:54.254Z">
<meta property="article:author" content="Guanglong Zhao">
<meta property="article:tag" content="UVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://scfmvp.github.io/img/logo.jpg"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://scfmvp.github.io/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UVMDemo学习笔记(一个简单的UVM验证平台)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-09 21:52:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/logo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Later的个人博客 "><span class="site-name">Later的个人博客 </span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UVMDemo学习笔记(一个简单的UVM验证平台)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-09T13:36:11.000Z" title="发表于 2023-08-09 21:36:11">2023-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-09T13:52:54.254Z" title="更新于 2023-08-09 21:52:54">2023-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DV/">DV</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DV/UVM/">UVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UVMDemo学习笔记(一个简单的UVM验证平台)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="UVMDemo学习笔记"><a href="#UVMDemo学习笔记" class="headerlink" title="UVMDemo学习笔记"></a>UVMDemo学习笔记</h1><blockquote>
<p>UVM实战：一个简单的UVM验证平台</p>
</blockquote>
<p> [TOC] </p>
<h1 id="跑通Demo"><a href="#跑通Demo" class="headerlink" title="跑通Demo"></a>跑通Demo</h1><p>使用<code>2.5.2</code>的例子作为文件。需要对应自己的环境进行修改，修改如下。</p>
<p>1、setup.vcs修改</p>
<p>对应修改到bash shell下，参照~&#x2F;.bashrc修改即可，很简单。</p>
<p>对应修改VCS_HOME等自己实际的环境变量</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691055817490.png" alt="1691055817490"></p>
<blockquote>
<p>bash和csh都是shell脚本语言。</p>
<p>Linux终端的核心组件是Shell，它是一个解释器，负责解析用户输入的命令并将其发送给操作系统执行。Linux中有多种Shell可用，其中最常见的是Bash（Bourne Again Shell），它是许多Linux发行版的默认Shell。其他常见的Shell包括csh。</p>
<p> <strong>bash</strong> 的 shell 默认用户下面的配置文件是：<code>.bashrc</code>, 用户登陆之后，默认执行该配置文件内容，让环境变量生效;<strong>csh</strong> 的 shell 默认用户下面的配置文件是：<code>.cshrc</code>， 用户登陆之后，默认执行该配置文件内容。很多脚本文件在第一行都需要指定所使用的shell，如：<code>#!/bin/bash</code></p>
<p>为什么有的terminal使用bash，而有的终端使用csh？ </p>
<p>Linux发行决定。也可以通过指定更换shell。</p>
</blockquote>
<p>2、修改运行脚本</p>
<p>加入-full64选项</p>
<blockquote>
<p>好奇：执行脚本指定csh，但是也可以执行，是以为语法正确的原因吗？配置环境的语法有问题所以不能执行而已。</p>
</blockquote>
<p>还要注意，使用虚拟机时不要把代码放在共享文件夹内编译</p>
<p>修改后，运行一下demo：</p>
<p>执行<code>source setup.vcs</code> 使环境变量生效。进入代码目录，执行<code>run_tc my_case0</code>，编译运行demo</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691057408627.png" alt="1691057408627"></p>
<h1 id="Demo学习"><a href="#Demo学习" class="headerlink" title="Demo学习"></a>Demo学习</h1><p>根据几张图，对应例程代码来学习理解这个验证平台。</p>
<ul>
<li>典型UVM验证平台框图（P8）</li>
<li>UVM树状图&#x2F;路径（P55,66,86）</li>
<li>UVM常用类的继承关系（P57）</li>
<li>UVM验证平台执行流程（P55）<ul>
<li>UVM中的phase（P132）</li>
</ul>
</li>
</ul>
<p>学习整理：</p>
<ul>
<li>验证平台各模块基本功能（P7）</li>
<li>代码与框图的对应（不涉及寄存器模型）</li>
<li>代码注释讲解（重点）</li>
</ul>
<h2 id="第一张图：典型UVM验证平台框架"><a href="#第一张图：典型UVM验证平台框架" class="headerlink" title="第一张图：典型UVM验证平台框架"></a>第一张图：典型UVM验证平台框架</h2><p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691456208017.png" alt="1691456208017"></p>
<p>先介绍平台中每一个模块的功能作用（P7）</p>
<ul>
<li>DUT是我们的待测设计模块，reference model就是参考模型，与DUT完成相同的过程。</li>
<li>sequence负责产生激励。sequencer则是负责将sequence生产的激励发送到driver。</li>
<li>driver将sequencer发送过来的数据，按照数据协议驱动到DUT上。</li>
<li>monitor则是采集激励和响应数据。</li>
<li>scoreboard是计分板，自动对比DUT输出和参考模型输出。</li>
<li>env：提供一个容器，</li>
</ul>
<p>当然除了这些模块，还会涉及到一些其他的。如虚接口（virtual interface）、agent等以及一些机制。</p>
<h2 id="第二张图：UVM树状图-x2F-路径"><a href="#第二张图：UVM树状图-x2F-路径" class="headerlink" title="第二张图：UVM树状图&#x2F;路径"></a>第二张图：UVM树状图&#x2F;路径</h2><p>这张图在P55，66也都出现过，这张图信息最完整，以此图<strong>UVM树</strong>进行学习理解。</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691456481828.png" alt="1691456481828"></p>
<p>这个便于理解代码的层次结构，也和执行顺序是相关的。</p>
<p>矩形框内第一行是模块名，实例名，也是每个模块路径。第二行括号内是UVM每个模块的类。矩形框旁边的new是例化模块时指定的名字。也是通过树的结点去访问UVM树中的每个模块。</p>
<p>UVM是以树的形式组织在一起的，作为一棵树来说，UVM中<strong>真正的树根是一个称为uvm_top</strong>的东西，在测试用例里实例化env，在env里实例化scoreboard、reference model、agent，在agent里面实例化sequencer、driver和monitor。scoreboard、reference model、sequencer、driver和monitor都是树的叶子。</p>
<p><strong>uvm_top：</strong></p>
<p>uvm_top是uvm_root类的唯一实例，由UVM创建和管理。所在的域是uvm_pkg。<br>uvm_top是所有test组件的顶层。<strong>所有验证环境中的组件在创建时都需要指明它的父一级</strong>（Parent）。 如果某些组件在创建时指定父一级的参数为“null”，那么它将直接隶属于uvm_top。 <strong>在实例化变量时指定parent变量，可以形成一个树状结构从而起到建立层次的作用</strong>。<br>uvm_top提供一系列的方法来控制仿真，例如phase机制、objection防止仿真退出机制等。</p>
<p><strong>uvm_test：</strong></p>
<p>test类是用户自定义类的顶层结构。所有的test类都应该<strong>继承于uvm_test</strong>，否则，uvm_top将不识别。<br>test的目标包括：</p>
<ul>
<li>提供不同的配置，包括环境结构配置、测试模式配置等，然后再创建验证环境。</li>
<li>例化测试序列，并且挂载（attach）到目标sequencer，使其命令driver发送激励。</li>
</ul>
<p>UVM树对应的框图上，也是自顶向下的。</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691458438716.png" alt="1691458438716"></p>
<p>树的作用就是便于组织验证。</p>
<h2 id="第三张图：UVM常用类的继承关系"><a href="#第三张图：UVM常用类的继承关系" class="headerlink" title="第三张图：UVM常用类的继承关系"></a>第三张图：UVM常用类的继承关系</h2><p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691458685403.png" alt="1691458685403"></p>
<blockquote>
<p>这是描述UVM类的，对应的宏也要学习一下</p>
<p>可以在第二张图上标注出每个模块的父类</p>
</blockquote>
<p>如图所示，验证平台的所有类都继承于<code>uvm_object</code>和<code>uvm_commponent</code>，而<code>uvm_commponent</code>又是继承于<code>uvm_object</code>的。</p>
<p>派生与uvm_object类的是transaction、sequence这些非模块的东西。</p>
<p><strong>派生于uvm_component类的才可以是UVM树的节点。</strong></p>
<p>白皮书上分子、血液、生命的例子比较好。</p>
<p>对应下这个平台各个成员的父类，如下图所示。</p>
<p><strong>uvm_component这边：</strong>reference直接派生与uvm_component，sequencer派生于uvm_component的子类uvm_sequencer。其他的都直接派生与uvm_component的直接子类。</p>
<p><strong>uvm_object这边：</strong>其实都是transaction服务的，有uvm_transaction继续向下派生。</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691461402331.png" alt="1691461402331"></p>
<p>分析代码里面的继承关系：</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691475056855.png" alt="1691475056855"></p>
<p>相关的宏：</p>
<blockquote>
<p>用的再补充</p>
</blockquote>
<h2 id="第四张图：UVM验证平台执行流程"><a href="#第四张图：UVM验证平台执行流程" class="headerlink" title="第四张图：UVM验证平台执行流程"></a>第四张图：UVM验证平台执行流程</h2><p>&#x3D;&#x3D;这里要深入分析，结合前后的知识内容。&#x3D;&#x3D;</p>
<p>UVM测试用例的启动及执行流程如下图所示：</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691462920655.png" alt="1691462920655"></p>
<p>由顶层的测试模块top_tb开始，</p>
<p><strong>1）top_tb：</strong></p>
<p>例化接口；例化DUT；生成仿真时钟、复位信号；通过uvm_config_db将接口传递给driver和monitor</p>
<p><code>import uvm_pkg::*;</code>在导入uvm_pkg文件包时，会自动创建一个顶层类uvm_root所例化的对象，及uvm_top</p>
<p>执行run_test()： run_test是在uvm_globals.svh中定义的一个task，用于启动UVM，创建测试用例的实例并运行。也就启动了验证平台。 run_test语句会创建一个my_case0的实例，得到正确的test_name 。<strong>然后依次执行uvm_test容器中的各个component组件中的phase机制</strong>。具体工作见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/nuoweishizi/article/details/126343435">uvm中run_test</a></p>
<p><strong>2）build_phase:</strong></p>
<p>依次执行build_phase(自顶而下)，形成完整的UVM树。</p>
<p>在phase机制和objection机制的控制下，执行phase。</p>
<p><strong>phase机制：</strong></p>
<p><em><strong>UVM验证平台由phase机制和objection机制来控制验证平台的运行。</strong></em></p>
<p>phase自上而下执行（时间）：安装P132图，不同phase的执行顺序。</p>
<p>phase自上而下执行&#x2F;自下而上（空间）：按照UVM树的路径，每个phase，如build_phase，先执行my_case中的build_phase，其次是env中的build_phase，一层层往下执行。<strong>对于tast phase，不同component中同名phase会同时运行P136</strong>。深度优先，一条支路走到叶子才会回头头别的P139。同级别则按字典顺序执行。</p>
<p>所以结合起来，phase执行顺序就是，先自顶向下执行build_phase。完成后再自顶向下执行connect_phase。</p>
<p>UVM的设计哲学就是在build_phase中做实例化工作。</p>
<p>phase执行<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shadrach/p/15664615.html">顺序</a></p>
<p> <img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/802651-20211208223032002-166742252.png" alt="img"></p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691476193111.png" alt="1691476193111"></p>
<p><strong>objection机制：</strong></p>
<p>只是对task phase的控制，一般在sequence里面挂起和取消。</p>
<p><strong>3）执行UVM树各节点的其他phase：</strong></p>
<p>自顶而下还是自下而上看上面的图</p>
<p><strong>4）所有phase执行完毕，结束仿真</strong></p>
<p>等待所有的phase执行结束，关闭phase控制进程。</p>
<p>报告总结和仿真结束。</p>
<h2 id="关于Transaction"><a href="#关于Transaction" class="headerlink" title="关于Transaction"></a>关于Transaction</h2><p>transaction：事务，个人理解为激励、数据。叫事务，会不会是因为一个transaction除了data还有function。</p>
<p>P20页有详细介绍：</p>
<p>transaction是一组数据或者是一个数据包，其基类是uvm_sequence_item。</p>
<p>transaction有生命周期，从sequence产生到scoreboard比较后，transaction的生命周期就结束了。那需要追踪下产生一个激励需要构建了多少个transaction，transaction的传输路径是怎样的，分析从产生到结束的过程。</p>
<p>用到transaction的代码文件：（可以看出事务的传输流程，框图中线上都是transaction？）</p>
<p>&#x3D;&#x3D;在uvm环境中，所有组件之间的通信都是通过transaction类型连通。&#x3D;&#x3D;</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691138882141.png" alt="1691138882141"></p>
<p>分析transaction传输过程：（基于验证平台执行过程）</p>
<p> <img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/verify_env.png" alt="img"></p>
<p>tr到DUT端口的转换：（driver）</p>
<p>将tr打包到数组中，在放入DUT的端口中。</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691479410630.png" alt="1691479410630"></p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691479455942.png" alt="1691479455942"></p>
<p>DUT端口到tr的转换：（monitor）</p>
<p>将DUT的端口数据打包成tr的形式。</p>
<p><img src="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1691479633235.png" alt="1691479633235"></p>
<h2 id="关于Vif"><a href="#关于Vif" class="headerlink" title="关于Vif"></a>关于Vif</h2><p>dut和验证平台之间的端口使用虚接口连接（P16）</p>
<p>好处就是避免绝对路径。</p>
<p>以一个interface为例进行理解分析：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> my_if(<span class="keyword">input</span> clk, <span class="keyword">input</span> rst_n);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">   <span class="keyword">logic</span> valid;</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p>按照module进行理解的话，它只声明了接口，但是没有使用。而且，接口的参数是<code>input clk, input rst_n</code>，而接口内部是两个信号。那么接口参数和接口内部的信号怎么区分理解呢？</p>
<p>想了想我的理解是这样：同样的用电路思维去考虑。一个接口电路要连接到两个module上，接口内部信号就是模块直接的连接信号，而输入的参数信号可以理解为接口模块外部给接口的信号。同样，接口作为module直接连接的模块，那这些模块的clk也是外部给进来的。</p>
<p>使用时是先定义interface接口<code>interface my_if</code>，在类中使用时虚接口<code>virtual my_if vif</code></p>
<h2 id="自己写代码的顺序-自己搭建平台"><a href="#自己写代码的顺序-自己搭建平台" class="headerlink" title="自己写代码的顺序-自己搭建平台"></a>自己写代码的顺序-自己搭建平台</h2><p>那知道了代码的层次结构，继承关系以及执行机制和顺序。那么要是自己搭建一个UVM验证平台，设计的顺序应该是怎么样的呢？</p>
<p>其实还是从DUT出发，为了测试DUT，我们要如何如测试它。</p>
<p>首先应该想到给DUT施加激励，构建<strong>driver模块</strong>。此时为了测试<strong>top_tb模块</strong>也可以先建立起来。在driver给DUT施加激励时又考虑到端口路径问题，还要设计一个<strong>接口interface</strong>。然后要考虑加入monitor和sequence，那么就要考虑组件之间信息传递，设计一个<strong>transaction模块</strong>。然后就可以设计<strong>monitor模块</strong>、<strong>sequencer模块</strong>。在此基础上设计<strong>agent</strong>，设计大的容器<strong>env模块</strong>。最后再加上reference model模块和scoreboard模块，整个模块就成型了。为了测试，还要写<strong>测试用例my_casen</strong>，这里面会包含<strong>sequence</strong>。</p>
<p>补充一下transaction，在和DUT交互时，主要时driver和monitor。driver是将tr转换成DUT的端口级数据，而monitor则是将DUT的端口级数据转换成tr形式的。</p>
<p>factory机制：自动创建一个类的实例并调用其中的function和task。</p>
<p>不同派生类使用不同的宏去注册。</p>
<p>uvm_conponent使用uvm_component_utils()去注册</p>
<p>派生于uvm_object的使用uvm_object_utils()去注册</p>
<p>factory注册的组件例化时也要用以下形式，验证平台的组件都是：</p>
<p><code>drv=my_driver::type_id::create(&quot;drv&quot;,this);</code></p>
<p>&#x3D;&#x3D;Todo:ch8&#x3D;&#x3D;</p>
<p>自己从头搭，一步步来： <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv19024102?spm_id_from=333.999.0.0">从零开始，搭建一个简单的UVM验证平台（一）</a> </p>
<h2 id="UVM相关宏"><a href="#UVM相关宏" class="headerlink" title="UVM相关宏"></a>UVM相关宏</h2><p>在UVM库里能看到</p>
<h2 id="运行相关机制"><a href="#运行相关机制" class="headerlink" title="运行相关机制"></a>运行相关机制</h2><p>ch5 已在上方整理</p>
<p>UVM验证平台执行流程</p>
<h2 id="代码阅读-注释-思考："><a href="#代码阅读-注释-思考：" class="headerlink" title="代码阅读+注释+思考："></a>代码阅读+注释+思考：</h2><p>带着疑问去学会看的更仔细，解决自己的疑问，这个知识点也就了解明白许多了。</p>
<p>按运行顺序还是构建顺序去注释。</p>
<p>构建吧，也就是按构建顺序的逻辑来的。执行顺序还会设计到很多的机制。</p>
<h3 id="DUT："><a href="#DUT：" class="headerlink" title="DUT："></a>DUT：</h3><p>很简单rxd接受数据，然后通过txd发送出去。还有发送使能信号和接受有效信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dut.sv</span></span><br><span class="line"><span class="keyword">module</span> dut(clk,                 <span class="comment">//DUT功能，通过rxd接受数据，再通过txd发送出去</span></span><br><span class="line">           rst_n,               <span class="comment">//复位信号</span></span><br><span class="line">           rxd,                 <span class="comment">//8bit的接收到的数据</span></span><br><span class="line">           rx_dv,               <span class="comment">//接受的数据有效位</span></span><br><span class="line">           txd,                 <span class="comment">//8bit的发送的数据 </span></span><br><span class="line">           tx_en);              <span class="comment">//发送信号的数据有效位</span></span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span> rst_n;                    <span class="comment">//对于这样一个简单的dut，使用UVM环境进行验证</span></span><br><span class="line"><span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] rxd;                 <span class="comment">//要造随机的测试用例作为激励给到dut，然后检测dut的输出信号，如果输出等于输入的话，那么说明dut功能正常</span></span><br><span class="line"><span class="keyword">input</span> rx_dv;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] txd;</span><br><span class="line"><span class="keyword">output</span> tx_en;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] txd;</span><br><span class="line"><span class="keyword">reg</span> tx_en;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">      txd &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">      tx_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      txd &lt;= rxd;</span><br><span class="line">      tx_en &lt;= rx_dv;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Driver："><a href="#Driver：" class="headerlink" title="Driver："></a>Driver：</h3><p>driver的功能就是将sequencer传递过来的数据驱动到DUT上。与DUT使用虚接口进行连接。</p>
<p>拿到sequencer是数据是：<code>seq_item_port.get_next_item(req);</code> </p>
<p>驱动是通过：<code>drive_one_pkt(req);</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_DRIVER__SV  </span><span class="comment">// 防止重复编译</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_DRIVER__SV</span></span><br><span class="line"><span class="keyword">class</span> my_driver <span class="keyword">extends</span> uvm_driver<span class="variable">#(my_transaction); // 继承与uvm_driver，#(my_transaction)</span>和verilog一样，是参数化的类/模块。这里是传入transaction类。</span><br><span class="line">   <span class="keyword">virtual</span> my_if vif;    <span class="comment">// 通过虚接口来连接UVM中的类（driver、monitor）和DUT</span></span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_driver)       <span class="comment">// factory机制：通过宏注册my_driver类。宏不要分号结尾    </span></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_driver&quot;</span>, uvm_component parent = <span class="literal">null</span>); <span class="comment">// 构造函数，派生自uvm_component的类在例化时，要指定name和parent两个参数。是为了确定在UVM树中的位置。</span></span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);    <span class="comment">// super是调用基类中的方法。扩展类的构造函数。如果父类的构造函数是有参数的，那么必须在子类中有一个构造函数函数，而且必须在子类的构造函数第一行调用父类的构造函数，包括sv的new,UVM的build_phase。（规则）</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);   <span class="comment">// phase机制：build_phase主要用于传递虚接口和例化类。</span></span><br><span class="line">      <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);   <span class="comment">// 按规则来的</span></span><br><span class="line">      <span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span> <span class="comment">//uvm_config_db是一个收寄新机制，此处是获取别处传递来的vif（此处参数不介绍），给上面定义的虚接口</span></span><br><span class="line">         `uvm_fatal(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;virtual interface must be set for vif!!!&quot;</span>) <span class="comment">//信息打印</span></span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">task</span> main_phase(uvm_phase phase);      <span class="comment">// extern是在类外定义方法，缩减类的长度。main_phase是task phase，是主要动作执行的位置</span></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">task</span> drive_one_pkt(my_transaction tr); <span class="comment">// 用户定义的task，负责驱动一个数据包到DUT</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_driver::main_phase(uvm_phase phase);  <span class="comment">// 通过类名调用类中的任务。此处是定义task</span></span><br><span class="line">   vif<span class="variable">.data</span> &lt;= <span class="number">8&#x27;b0</span>;     <span class="comment">// </span></span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!vif<span class="variable">.rst_n</span>)       <span class="comment">// 非复位状态时，等待时钟沿。就是说复位后才会执行下面的。</span></span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);  </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) <span class="keyword">begin</span>          <span class="comment">// driver执行的任务时一直进行的。</span></span><br><span class="line">       seq_item_port<span class="variable">.get_next_item</span>(req); <span class="comment">// P45 seq_item_port是driver中的TLM传输的方法，使用get_next_item从sequencer中得到数据包req(P42)</span></span><br><span class="line">      drive_one_pkt(req);  <span class="comment">// 发送数据包到dut</span></span><br><span class="line">      seq_item_port<span class="variable">.item_done</span>();        <span class="comment">// 这里driver调用了get_next_item和item_done是driver和sequencer之间的握手机制，调用item_done表示driver成功的驱动了req，sequencer可以发送新数据了，如果没有调用item_done的话，sequencer会重新发送之前的数据，直到item_done被调用</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_driver::drive_one_pkt(my_transaction tr); <span class="comment">// driver驱动数据包到DUT</span></span><br><span class="line">   <span class="keyword">byte</span> <span class="keyword">unsigned</span>     data_q[]; <span class="comment">// 8bit位宽的无符号动态数组</span></span><br><span class="line">   <span class="keyword">int</span>  data_size;             <span class="comment">// 数据量（byte）</span></span><br><span class="line">   </span><br><span class="line">   data_size = tr<span class="variable">.pack_bytes</span>(data_q) / <span class="number">8</span>;   <span class="comment">//pack_bytes是将tr数据打包成bytes数据，放到data_q中。</span></span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;begin to drive one pkt&quot;</span>, UVM_LOW); <span class="comment">//信息打印</span></span><br><span class="line">   <span class="keyword">repeat</span>(<span class="number">3</span>) @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);      <span class="comment">// </span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data_size; i++ ) <span class="keyword">begin</span></span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);       <span class="comment">// 在时钟上升沿将tr数据驱动给虚接口。</span></span><br><span class="line">      vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b1</span>;      </span><br><span class="line">      vif<span class="variable">.data</span> &lt;= data_q[i];    <span class="comment">// 每个时钟传输8bit</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);   <span class="comment">// 数据传输完成后将使能信号拉低。</span></span><br><span class="line">   vif<span class="variable">.valid</span> &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   `uvm_info(<span class="string">&quot;my_driver&quot;</span>, <span class="string">&quot;end drive one pkt&quot;</span>, UVM_LOW);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Interface："><a href="#Interface：" class="headerlink" title="Interface："></a>Interface：</h3><p>好处是使用信号接口不受路径变化影响。</p>
<p>在类中使用要是虚拟接口。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_IF__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_IF__SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> my_if(<span class="keyword">input</span> clk, <span class="keyword">input</span> rst_n);  <span class="comment">// 接口信号，需要外部给</span></span><br><span class="line">   <span class="comment">// 接口内信号</span></span><br><span class="line">   <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data;   <span class="comment">// 8bit数据信号</span></span><br><span class="line">   <span class="keyword">logic</span> valid;        <span class="comment">// 使能信号</span></span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>那他是如何和DUT的数据对应上的呢？看下DUT例化部分就明白了。</p>
<p>DUT也是用了两组接口，input一组，output一组。</p>
<p>那么接口信号更复杂的话，我们该如何设计接口，需要学习一下。多看几个例子应该能明白。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_if input_if(clk, rst_n);</span><br><span class="line">my_if output_if(clk, rst_n);</span><br><span class="line"></span><br><span class="line">dut my_dut(<span class="variable">.clk</span>(clk),</span><br><span class="line">           <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">           <span class="variable">.rxd</span>(input_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.rx_dv</span>(input_if<span class="variable">.valid</span>),</span><br><span class="line">           <span class="variable">.txd</span>(output_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.tx_en</span>(output_if<span class="variable">.valid</span>));</span><br></pre></td></tr></table></figure>

<h3 id="Transaction："><a href="#Transaction：" class="headerlink" title="Transaction："></a>Transaction：</h3><p>定义数据包内容，随机约束和相关处理方法。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_TRANSACTION__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_TRANSACTION__SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_transaction <span class="keyword">extends</span> uvm_sequence_item; <span class="comment">// 派生于uvm_sequence_item类</span></span><br><span class="line">   <span class="comment">// 以太网帧格式</span></span><br><span class="line">   <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">47</span>:<span class="number">0</span>] dmac;</span><br><span class="line">   <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">47</span>:<span class="number">0</span>] smac;</span><br><span class="line">   <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">15</span>:<span class="number">0</span>] ether_type;</span><br><span class="line">   <span class="keyword">rand</span> <span class="keyword">byte</span>      pload[];</span><br><span class="line">   <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] crc;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">constraint</span> pload_cons&#123;  <span class="comment">// 随机约束</span></span><br><span class="line">      pload<span class="variable">.size</span> &gt;= <span class="number">46</span>;</span><br><span class="line">      pload<span class="variable">.size</span> &lt;= <span class="number">1500</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] calc_crc();   <span class="comment">// 假装是crc计算</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">32&#x27;h0</span>;</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">void</span> post_randomize();  <span class="comment">// sv提供的函数，此类被随机化后，随后无条件执行此方法。</span></span><br><span class="line">      crc = calc_crc;</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   `uvm_object_utils_begin(my_transaction)      <span class="comment">//通过field_automation机制，注册transation中的成员变量，之后就能使用uvm中的宏来处理这些数据</span></span><br><span class="line"></span><br><span class="line">      `uvm_field_int(dmac, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_int(smac, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_int(ether_type, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_array_int(pload, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_int(crc, UVM_ALL_ON)</span><br><span class="line">   `uvm_object_utils_end</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_transaction&quot;</span>);  <span class="comment">// 不是UVM树上的节点，所有不需要parent这个参数</span></span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>();</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Monitor："><a href="#Monitor：" class="headerlink" title="Monitor："></a>Monitor：</h3><p>monitor是负责采集DUT的输入输出，用于scoreboard的自动比较。</p>
<p>重点还是下面几行代码？手机DUT的数据，转换成tr，再写出去。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tr = <span class="keyword">new</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">collect_one_pkt(tr);</span><br><span class="line">ap<span class="variable">.write</span>(tr);</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_MONITOR__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_MONITOR__SV</span></span><br><span class="line"><span class="keyword">class</span> my_monitor <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">virtual</span> my_if vif;    <span class="comment">// 虚接口</span></span><br><span class="line"></span><br><span class="line">   uvm_analysis_port <span class="variable">#(my_transaction)</span>  ap;     <span class="comment">//TLM的发送数据的参数化的类，其参数就是需要传递的数据的类型，这里声明一个句柄。（需要进一步了解）</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   `uvm_component_utils(my_monitor)   <span class="comment">// factory注册</span></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_monitor&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">      <span class="keyword">if</span>(!uvm_config_db<span class="variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span></span><br><span class="line">         `uvm_fatal(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;virtual interface must be set for vif!!!&quot;</span>)</span><br><span class="line">      ap = <span class="keyword">new</span>(<span class="string">&quot;ap&quot;</span>, <span class="keyword">this</span>);   <span class="comment">// 例化TLM发送数据的类</span></span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">task</span> main_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">task</span> collect_one_pkt(my_transaction tr);  <span class="comment">// 抓取数据包port到tr</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_monitor::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) <span class="keyword">begin</span>          <span class="comment">// 持续抓取数据包</span></span><br><span class="line">      tr = <span class="keyword">new</span>(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">      collect_one_pkt(tr); <span class="comment">// 抓取一个数据包</span></span><br><span class="line">      ap<span class="variable">.write</span>(tr);        <span class="comment">// 写入一个tr，写给了谁？谁会收到？</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_monitor::collect_one_pkt(my_transaction tr);</span><br><span class="line">   <span class="keyword">byte</span> <span class="keyword">unsigned</span> data_q[$];     <span class="comment">// 队列</span></span><br><span class="line">   <span class="keyword">byte</span> <span class="keyword">unsigned</span> data_array[];  <span class="comment">// 动态数组</span></span><br><span class="line">   <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data;     <span class="comment">// 对应虚接口</span></span><br><span class="line">   <span class="keyword">logic</span> valid = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> data_size;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) <span class="keyword">begin</span>             <span class="comment">// 等待数据有效，开始抓取数据</span></span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">      <span class="keyword">if</span>(vif<span class="variable">.valid</span>) <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line">   `uvm_info(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;begin to collect one pkt&quot;</span>, UVM_LOW);</span><br><span class="line">   <span class="keyword">while</span>(vif<span class="variable">.valid</span>) <span class="keyword">begin</span></span><br><span class="line">      data_q<span class="variable">.push_back</span>(vif<span class="variable">.data</span>);    <span class="comment">// 在有效期间,将虚接口上的数据插入队尾</span></span><br><span class="line">      @(<span class="keyword">posedge</span> vif<span class="variable">.clk</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   data_size  = data_q<span class="variable">.size</span>();    </span><br><span class="line">   data_array = <span class="keyword">new</span>[data_size];      <span class="comment">// 分配动态数组</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data_size; i++ ) <span class="keyword">begin</span></span><br><span class="line">      data_array[i] = data_q[i];     <span class="comment">// 把队列数据放入动态数组中</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   tr<span class="variable">.pload</span> = <span class="keyword">new</span>[data_size - <span class="number">18</span>]; <span class="comment">//da sa, e_type, crc  // 根据实际数据大小,给pload分配内存</span></span><br><span class="line">   data_size = tr<span class="variable">.unpack_bytes</span>(data_array) / <span class="number">8</span>;  <span class="comment">// 把bytes流转换成tr中的各个字段.unpack_bytes的参数必须为动态数组</span></span><br><span class="line">   `uvm_info(<span class="string">&quot;my_monitor&quot;</span>, <span class="string">&quot;end collect one pkt&quot;</span>, UVM_LOW);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Sqeuencer"><a href="#Sqeuencer" class="headerlink" title="Sqeuencer"></a>Sqeuencer</h3><p>sequencer是负责发送sequence的，代码比较简单。</p>
<p>重点在于sequence的设计。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_SEQUENCER__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_SEQUENCER__SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_sequencer <span class="keyword">extends</span> uvm_sequencer <span class="variable">#(my_transaction)</span>;     <span class="comment">//my_sequencer只是driver和sequence之间的桥梁，在其他层次设定了在此处启动sequence   </span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">   <span class="keyword">endfunction</span> </span><br><span class="line">   </span><br><span class="line">   `uvm_component_utils(my_sequencer)   <span class="comment">// factory注册</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Agent："><a href="#Agent：" class="headerlink" title="Agent："></a>Agent：</h3><p>agent这里是将sqr、drv、mon三个组件封装到一起了。再agent里根据uvm成员变量，决定哪些组件是需要的。然后再通过connect_phase将组件连接再一起。</p>
<p>通过agent也可以知道，之前sequencer的sequencer是发给drv的，或者说drv从sqr处拿到tr。</p>
<p>mon生产的tr也是通过ap向上发送的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_AGENT__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_AGENT__SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_agent <span class="keyword">extends</span> uvm_agent ;</span><br><span class="line"> <span class="comment">//agent中封装了三个组件 sequence driver monitor,他们三个因为关系密切被封装到一起，driver从sequencer中拿到激励</span></span><br><span class="line"></span><br><span class="line">   my_sequencer  sqr;</span><br><span class="line"> <span class="comment">//monitor和drv处理的是同一种协议，drv把transation的数据转换为dut端口可使用的数据，而monitor把dut的端口数据转换为 transaction中能检测的数据类型</span></span><br><span class="line">   my_driver     drv;</span><br><span class="line">   my_monitor    mon;</span><br><span class="line">   </span><br><span class="line">   uvm_analysis_port <span class="variable">#(my_transaction)</span>  ap;     <span class="comment">//uvm_analysis_port是TLM传输级别的一种发送方式，是一个参数化的类，参数就是发送数据的类型.</span></span><br><span class="line">   <span class="comment">// 发送给谁? 看连接.</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">   <span class="keyword">endfunction</span> </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase); <span class="comment">// 负责各模块之间的连接</span></span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_agent)   <span class="comment">// factory 注册</span></span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> my_agent::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">   <span class="keyword">if</span> (is_active == UVM_ACTIVE) <span class="keyword">begin</span>  <span class="comment">// is_active是uvm_agent中的成员变量，默认是UVM_ACTIVE, 例化全部.当is_active == UVM_PASSIVE时，只需要例化monitor.</span></span><br><span class="line">                                       <span class="comment">// 这个成员变量在env里设置了</span></span><br><span class="line">      sqr = my_sequencer::type_id::create(<span class="string">&quot;sqr&quot;</span>, <span class="keyword">this</span>);   <span class="comment">// 例化成员变量,UVM  </span></span><br><span class="line">      drv = my_driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   mon = my_monitor::type_id::create(<span class="string">&quot;mon&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> my_agent::connect_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">   <span class="keyword">if</span> (is_active == UVM_ACTIVE) <span class="keyword">begin</span></span><br><span class="line">      drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);  <span class="comment">// drv和sqr相连接,这个port在drv里有出现,sqr里没有,回头看看.</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   ap = mon<span class="variable">.ap</span>;     <span class="comment">// 这里的ap和mon中的ap相连接.</span></span><br><span class="line">                    <span class="comment">// 也就是说,mon写的数据,发送到agent了.在env还会有connect_phase,ap还会再连接,数据还会再发送.</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Reference-model："><a href="#Reference-model：" class="headerlink" title="Reference model："></a>Reference model：</h3><p>参考模型这里还存在一些疑问：</p>
<p>1、高层次语言写的，时序关系需要吗？能实现到时序级别吗？</p>
<p>2、参考模型如何保证正确性。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_MODEL__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_MODEL__SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_model <span class="keyword">extends</span> uvm_component;</span><br><span class="line">   </span><br><span class="line">   uvm_blocking_get_port <span class="variable">#(my_transaction)</span>  port;  <span class="comment">// 接受数据用</span></span><br><span class="line">   uvm_analysis_port <span class="variable">#(my_transaction)</span>  ap;        <span class="comment">// 发送数据用</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span>  <span class="keyword">task</span> main_phase(uvm_phase phase);</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_model)</span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> my_model::<span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> my_model::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">   port = <span class="keyword">new</span>(<span class="string">&quot;port&quot;</span>, <span class="keyword">this</span>);      <span class="comment">// 例化,非factory注册(非验证平台组件),用new构造.</span></span><br><span class="line">   ap = <span class="keyword">new</span>(<span class="string">&quot;ap&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_model::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;       <span class="comment">// 获取数据用</span></span><br><span class="line">   my_transaction new_tr;   <span class="comment">// 发送数据用</span></span><br><span class="line">   <span class="keyword">super</span><span class="variable">.main_phase</span>(phase);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) <span class="keyword">begin</span>        <span class="comment">// 持续比较</span></span><br><span class="line">      port<span class="variable">.get</span>(tr);      <span class="comment">// 获取数据(iagt.mon)</span></span><br><span class="line">      new_tr = <span class="keyword">new</span>(<span class="string">&quot;new_tr&quot;</span>);</span><br><span class="line">      new_tr<span class="variable">.copy</span>(tr);   <span class="comment">// 参考模型实体.收到什么数据发什么数据(copy)</span></span><br><span class="line">      `uvm_info(<span class="string">&quot;my_model&quot;</span>, <span class="string">&quot;get one transaction, copy and print it:&quot;</span>, UVM_LOW)</span><br><span class="line">      new_tr<span class="variable">.print</span>();    </span><br><span class="line">      ap<span class="variable">.write</span>(new_tr);  <span class="comment">// 输出数据(到scoreboard),发送对象实在env层次指定的.</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Scoreboard："><a href="#Scoreboard：" class="headerlink" title="Scoreboard："></a>Scoreboard：</h3><p>scoreboard比较固定化，没有什么要特殊处理的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_SCOREBOARD__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_SCOREBOARD__SV</span></span><br><span class="line"><span class="keyword">class</span> my_scoreboard <span class="keyword">extends</span> uvm_scoreboard;</span><br><span class="line">   my_transaction  expect_queue[$];</span><br><span class="line">   uvm_blocking_get_port <span class="variable">#(my_transaction)  exp_port; // 期望数据(来自ref model)</span></span><br><span class="line">   uvm_blocking_get_port <span class="variable">#(my_transaction)  act_port; // 实际数据(来自oagt.mon)</span></span><br><span class="line">   `uvm_component_utils(my_scoreboard)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> main_phase(uvm_phase phase);</span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> my_scoreboard::<span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line"><span class="keyword">endfunction</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> my_scoreboard::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">   exp_port = <span class="keyword">new</span>(<span class="string">&quot;exp_port&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   act_port = <span class="keyword">new</span>(<span class="string">&quot;act_port&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">endfunction</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_scoreboard::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction  get_expect,  get_actual, tmp_tran;</span><br><span class="line">   <span class="keyword">bit</span> result;    <span class="comment">// 比较结果</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">super</span><span class="variable">.main_phase</span>(phase);</span><br><span class="line">   <span class="keyword">fork</span>     <span class="comment">// fork...join,分别处理两个来向的数据,其中一个还负责比较</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">         exp_port<span class="variable">.get</span>(get_expect);</span><br><span class="line">         expect_queue<span class="variable">.push_back</span>(get_expect);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">         act_port<span class="variable">.get</span>(get_actual);</span><br><span class="line">         <span class="keyword">if</span>(expect_queue<span class="variable">.size</span>() &gt; <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">            tmp_tran = expect_queue<span class="variable">.pop_front</span>();</span><br><span class="line">            result = get_actual<span class="variable">.compare</span>(tmp_tran);  <span class="comment">// compare是哪来的</span></span><br><span class="line">            <span class="keyword">if</span>(result) <span class="keyword">begin</span> </span><br><span class="line">               `uvm_info(<span class="string">&quot;my_scoreboard&quot;</span>, <span class="string">&quot;Compare SUCCESSFULLY&quot;</span>, UVM_LOW);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">               `uvm_error(<span class="string">&quot;my_scoreboard&quot;</span>, <span class="string">&quot;Compare FAILED&quot;</span>);</span><br><span class="line">               <span class="built_in">$display</span>(<span class="string">&quot;the expect pkt is&quot;</span>);</span><br><span class="line">               tmp_tran<span class="variable">.print</span>();</span><br><span class="line">               <span class="built_in">$display</span>(<span class="string">&quot;the actual pkt is&quot;</span>);</span><br><span class="line">               get_actual<span class="variable">.print</span>();</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            `uvm_error(<span class="string">&quot;my_scoreboard&quot;</span>, <span class="string">&quot;Received from DUT, while Expect Queue is empty&quot;</span>);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;the unexpected pkt is&quot;</span>);</span><br><span class="line">            get_actual<span class="variable">.print</span>();</span><br><span class="line">         <span class="keyword">end</span> </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="Env："><a href="#Env：" class="headerlink" title="Env："></a>Env：</h3><p>主要做了两件事，<strong>例化</strong>和连接。平台的所有组件都是在此处例化的。env实在哪里呢？</p>
<p>还用到了tlm中的fifo就行数据传输。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_ENV__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_ENV__SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_env <span class="keyword">extends</span> uvm_env;       <span class="comment">//是一个容器，用于例化/连接各个组件，都是TLM级别传输</span></span><br><span class="line"></span><br><span class="line">   my_agent   i_agt;</span><br><span class="line">   my_agent   o_agt;</span><br><span class="line">   my_model   mdl;</span><br><span class="line">   my_scoreboard scb;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// tlm的fifo</span></span><br><span class="line">   uvm_tlm_analysis_fifo <span class="variable">#(my_transaction)</span> agt_scb_fifo;  <span class="comment">// 声明一个参数化类,参数是传输数据的类型.</span></span><br><span class="line">   uvm_tlm_analysis_fifo <span class="variable">#(my_transaction)</span> agt_mdl_fifo;  </span><br><span class="line">   uvm_tlm_analysis_fifo <span class="variable">#(my_transaction)</span> mdl_scb_fifo;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_env&quot;</span>, uvm_component parent);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">      i_agt = my_agent::type_id::create(<span class="string">&quot;i_agt&quot;</span>, <span class="keyword">this</span>); <span class="comment">//factory注册,特有的例化形式.this是my_env</span></span><br><span class="line">      o_agt = my_agent::type_id::create(<span class="string">&quot;o_agt&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">      i_agt<span class="variable">.is_active</span> = UVM_ACTIVE;               <span class="comment">// is_active设置为UVM_ACTIVE,则例化sqr,drv,和mon</span></span><br><span class="line">      o_agt<span class="variable">.is_active</span> = UVM_PASSIVE;              <span class="comment">// is_active设置为UVM_PASSIVE,则只例化mon</span></span><br><span class="line">      mdl = my_model::type_id::create(<span class="string">&quot;mdl&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">      scb = my_scoreboard::type_id::create(<span class="string">&quot;scb&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">      agt_scb_fifo = <span class="keyword">new</span>(<span class="string">&quot;agt_scb_fifo&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">      agt_mdl_fifo = <span class="keyword">new</span>(<span class="string">&quot;agt_mdl_fifo&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">      mdl_scb_fifo = <span class="keyword">new</span>(<span class="string">&quot;mdl_scb_fifo&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">   </span><br><span class="line">   `uvm_component_utils(my_env)</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> my_env::connect_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">   i_agt<span class="variable">.ap</span><span class="variable">.connect</span>(agt_mdl_fifo<span class="variable">.analysis_export</span>);      <span class="comment">// 连接关系,仔细看就明白</span></span><br><span class="line">   mdl<span class="variable">.port</span><span class="variable">.connect</span>(agt_mdl_fifo<span class="variable">.blocking_get_export</span>);</span><br><span class="line">   mdl<span class="variable">.ap</span><span class="variable">.connect</span>(mdl_scb_fifo<span class="variable">.analysis_export</span>);</span><br><span class="line">   scb<span class="variable">.exp_port</span><span class="variable">.connect</span>(mdl_scb_fifo<span class="variable">.blocking_get_export</span>);</span><br><span class="line">   o_agt<span class="variable">.ap</span><span class="variable">.connect</span>(agt_scb_fifo<span class="variable">.analysis_export</span>);</span><br><span class="line">   scb<span class="variable">.act_port</span><span class="variable">.connect</span>(agt_scb_fifo<span class="variable">.blocking_get_export</span>); </span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Case："><a href="#Case：" class="headerlink" title="Case："></a>Case：</h3><p>base_test，测试用例基于base_test。</p>
<p>属于测试用例的基础，是下面的顶层，例化env。同时还有打印信息。用例发送不同的激励在每个case中去实现。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> BASE_TEST__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> BASE_TEST__SV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> base_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line"></span><br><span class="line">   my_env         env;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;base_test&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name,parent);</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> report_phase(uvm_phase phase);</span><br><span class="line">   `uvm_component_utils(base_test)</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> base_test::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">   env  =  my_env::type_id::create(<span class="string">&quot;env&quot;</span>, <span class="keyword">this</span>);   <span class="comment">// 例化env</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//report_phase再main_phase结束后执行，打印一些错误信息等</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> base_test::report_phase(uvm_phase phase);</span><br><span class="line">   uvm_report_server server;</span><br><span class="line">   <span class="keyword">int</span> err_num;</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.report_phase</span>(phase);</span><br><span class="line"></span><br><span class="line">   server = get_report_server();</span><br><span class="line">   err_num = server<span class="variable">.get_severity_count</span>(UVM_ERROR);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (err_num != <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;TEST CASE FAILED&quot;</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;TEST CASE PASSED&quot;</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>my_case0：</p>
<p>这里面有两个类，一个是sequence一个是case。</p>
<p>case启动：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uvm_config_db<span class="variable">#(uvm_object_wrapper)</span>::set(<span class="keyword">this</span>, </span><br><span class="line">                                           <span class="string">&quot;env.i_agt.sqr.main_phase&quot;</span>, </span><br><span class="line">                                           <span class="string">&quot;default_sequence&quot;</span>, </span><br><span class="line">                                           case0_sequence::type_id::get());</span><br></pre></td></tr></table></figure>

<p>执行sequence中的&#96;&#96;uvm_do(m_trans)<code> 宏。就将tr发送到sequencer。driver通过</code>seq_item_port.get_next_item(req);&#96; 获取sequencer中的tr。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> MY_CASE0__SV</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> MY_CASE0__SV</span></span><br><span class="line"><span class="keyword">class</span> case0_sequence <span class="keyword">extends</span> uvm_sequence <span class="variable">#(my_transaction)</span>; <span class="comment">//用例也是一个参数化的类，参数是准备处理的数据包</span></span><br><span class="line">   my_transaction m_trans;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span>  <span class="keyword">new</span>(<span class="keyword">string</span> name= <span class="string">&quot;case0_sequence&quot;</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">   <span class="keyword">endfunction</span> </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">virtual</span> <span class="keyword">task</span> body();   <span class="comment">// 每个sequence都有一个body任务,sequence启动是会自动执行body任务.</span></span><br><span class="line">      <span class="keyword">if</span>(starting_phase != <span class="literal">null</span>)    <span class="comment">// default_sequence启动后,会得到一个starting_phase</span></span><br><span class="line">         starting_phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);   <span class="comment">// objection机制,控制phase执行与结束.</span></span><br><span class="line">      <span class="keyword">repeat</span> (<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">         `uvm_do(m_trans)   <span class="comment">//P45. 1.实例化m_trans,2.将其随机化,3.把m_trans传给sequencer</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      #<span class="number">100</span>;        <span class="comment">// 留有时间余量,sequence结束,其他动作未必结束.时间根据激励自行确定.</span></span><br><span class="line">      <span class="keyword">if</span>(starting_phase != <span class="literal">null</span>) </span><br><span class="line">         starting_phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">   `uvm_object_utils(case0_sequence)</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> my_case0 <span class="keyword">extends</span> base_test;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;my_case0&quot;</span>, uvm_component parent = <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">super</span><span class="variable">.new</span>(name,parent);</span><br><span class="line">   <span class="keyword">endfunction</span> </span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase); </span><br><span class="line">   `uvm_component_utils(my_case0)</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> my_case0::build_phase(uvm_phase phase);</span><br><span class="line">   <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">   <span class="comment">// 启动sequence,发送给sqr的default_sequence,值是sequence的id: case0_sequence.</span></span><br><span class="line">   <span class="comment">// P48 只需set,get UVM做了. #(uvm_object_wrapper)也是约定的,main_phase也是</span></span><br><span class="line">   <span class="comment">// 固定要求.</span></span><br><span class="line">   <span class="comment">// 下面语句就启动了sequence</span></span><br><span class="line">   uvm_config_db<span class="variable">#(uvm_object_wrapper)</span>::set(<span class="keyword">this</span>, </span><br><span class="line">                                           <span class="string">&quot;env.i_agt.sqr.main_phase&quot;</span>, </span><br><span class="line">                                           <span class="string">&quot;default_sequence&quot;</span>, </span><br><span class="line">                                           case0_sequence::type_id::get());</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Top："><a href="#Top：" class="headerlink" title="Top："></a>Top：</h3><p>top_tb.sv</p>
<p>这是仿真的最顶层</p>
<p>设置：时间精度，引入宏、库、包，发送虚接口</p>
<p>例化：例化DUT</p>
<p>执行：执行run_test()，启动仿真</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps             </span><span class="comment">// 定义仿真单位/仿真精度</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;uvm_macros.svh&quot;      </span><span class="comment">// UVM宏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;             <span class="comment">// UVM库,导入后会自动创建一个顶层类uvm_root所例化的对象</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_if.sv&quot;            </span><span class="comment">// 仿真文件调用</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_transaction.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_sequencer.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_driver.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_monitor.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_agent.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_model.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_scoreboard.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_env.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;base_test.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_case0.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;my_case1.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top_tb;    <span class="comment">// 测试最顶层,包含UVM顶层.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst_n;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rxd;</span><br><span class="line"><span class="keyword">reg</span> rx_dv;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] txd;</span><br><span class="line"><span class="keyword">wire</span> tx_en;</span><br><span class="line"></span><br><span class="line">my_if input_if(clk, rst_n);   <span class="comment">// 接口</span></span><br><span class="line">my_if output_if(clk, rst_n);</span><br><span class="line"></span><br><span class="line">dut my_dut(<span class="variable">.clk</span>(clk),         <span class="comment">// 例化DUT</span></span><br><span class="line">           <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">           <span class="variable">.rxd</span>(input_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.rx_dv</span>(input_if<span class="variable">.valid</span>),</span><br><span class="line">           <span class="variable">.txd</span>(output_if<span class="variable">.data</span>),</span><br><span class="line">           <span class="variable">.tx_en</span>(output_if<span class="variable">.valid</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>                 <span class="comment">// 生成clk</span></span><br><span class="line">   clk = <span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      #<span class="number">100</span> clk = ~clk;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>                 <span class="comment">// 生成复位信号</span></span><br><span class="line">   rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">   #<span class="number">1000</span>;</span><br><span class="line">   rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>               </span><br><span class="line"><span class="comment">//括号中如果有参数的话，应该是一个字符串类型如，run_test(&quot;my_case0&quot;)。将会自动创建一个my_case0的实例，例化名为uvm_test_top。并自动&quot;调用该my_case0中的main_phase&quot;。case中没有main_phase呢?</span></span><br><span class="line"><span class="comment">//这里括号中没有参数，是为了多个用例的选择，通过仿真时指定 +UVM_TESTNAME = my_case1来指定测试用例。</span></span><br><span class="line">   run_test();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// 将接口发送给drv,mon模块.</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   uvm_config_db<span class="variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.drv&quot;, &quot;vif&quot;, input_if)</span>;</span><br><span class="line">   uvm_config_db<span class="variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.mon&quot;, &quot;vif&quot;, input_if)</span>;</span><br><span class="line">   uvm_config_db<span class="variable">#(virtual my_if)::set(null, &quot;uvm_test_top.env.o_agt.mon&quot;, &quot;vif&quot;, output_if)</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://SCFMVP.github.io">Guanglong Zhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://scfmvp.github.io/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://scfmvp.github.io/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://SCFMVP.github.io" target="_blank">Later的个人博客 </a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UVM/">UVM</a></div><div class="post_share"><div class="social-share" data-image="/img/logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/11/DV/UVM/UVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%91%98%E8%AE%B0/" title="UVM知识点摘记（Ch2）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UVM知识点摘记（Ch2）</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/31/DV/Tools/Gvim%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/" title="Windows下Gvim安装与配置-续"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Windows下Gvim安装与配置-续</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/15/DV/UVM/CH3/" title="UVM知识点摘记（Ch3）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-15</div><div class="title">UVM知识点摘记（Ch3）</div></div></a></div><div><a href="/2023/08/21/DV/UVM/CH4/" title="UVM知识点摘记（Ch4）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-21</div><div class="title">UVM知识点摘记（Ch4）</div></div></a></div><div><a href="/2023/08/11/DV/UVM/UVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%91%98%E8%AE%B0/" title="UVM知识点摘记（Ch2）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-11</div><div class="title">UVM知识点摘记（Ch2）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/logo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Guanglong Zhao</div><div class="author-info__description">Learning Recording Sharing</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SCFMVP"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SCFMVP" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:scfmvp@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">UVMDemo学习笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%91%E9%80%9ADemo"><span class="toc-number">2.</span> <span class="toc-text">跑通Demo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Demo%E5%AD%A6%E4%B9%A0"><span class="toc-number">3.</span> <span class="toc-text">Demo学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%EF%BC%9A%E5%85%B8%E5%9E%8BUVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6"><span class="toc-number">3.1.</span> <span class="toc-text">第一张图：典型UVM验证平台框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%BC%A0%E5%9B%BE%EF%BC%9AUVM%E6%A0%91%E7%8A%B6%E5%9B%BE-x2F-%E8%B7%AF%E5%BE%84"><span class="toc-number">3.2.</span> <span class="toc-text">第二张图：UVM树状图&#x2F;路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%BC%A0%E5%9B%BE%EF%BC%9AUVM%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">第三张图：UVM常用类的继承关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E5%BC%A0%E5%9B%BE%EF%BC%9AUVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">第四张图：UVM验证平台执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ETransaction"><span class="toc-number">3.5.</span> <span class="toc-text">关于Transaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EVif"><span class="toc-number">3.6.</span> <span class="toc-text">关于Vif</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E9%A1%BA%E5%BA%8F-%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0"><span class="toc-number">3.7.</span> <span class="toc-text">自己写代码的顺序-自己搭建平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UVM%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-number">3.8.</span> <span class="toc-text">UVM相关宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">3.9.</span> <span class="toc-text">运行相关机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-%E6%B3%A8%E9%87%8A-%E6%80%9D%E8%80%83%EF%BC%9A"><span class="toc-number">3.10.</span> <span class="toc-text">代码阅读+注释+思考：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DUT%EF%BC%9A"><span class="toc-number">3.10.1.</span> <span class="toc-text">DUT：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Driver%EF%BC%9A"><span class="toc-number">3.10.2.</span> <span class="toc-text">Driver：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface%EF%BC%9A"><span class="toc-number">3.10.3.</span> <span class="toc-text">Interface：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transaction%EF%BC%9A"><span class="toc-number">3.10.4.</span> <span class="toc-text">Transaction：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor%EF%BC%9A"><span class="toc-number">3.10.5.</span> <span class="toc-text">Monitor：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sqeuencer"><span class="toc-number">3.10.6.</span> <span class="toc-text">Sqeuencer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Agent%EF%BC%9A"><span class="toc-number">3.10.7.</span> <span class="toc-text">Agent：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-model%EF%BC%9A"><span class="toc-number">3.10.8.</span> <span class="toc-text">Reference model：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scoreboard%EF%BC%9A"><span class="toc-number">3.10.9.</span> <span class="toc-text">Scoreboard：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Env%EF%BC%9A"><span class="toc-number">3.10.10.</span> <span class="toc-text">Env：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case%EF%BC%9A"><span class="toc-number">3.10.11.</span> <span class="toc-text">Case：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Top%EF%BC%9A"><span class="toc-number">3.10.12.</span> <span class="toc-text">Top：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/21/DV/UVM/CH4/" title="UVM知识点摘记（Ch4）">UVM知识点摘记（Ch4）</a><time datetime="2023-08-21T02:06:59.000Z" title="发表于 2023-08-21 10:06:59">2023-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/15/DV/UVM/CH3/" title="UVM知识点摘记（Ch3）">UVM知识点摘记（Ch3）</a><time datetime="2023-08-15T11:42:22.000Z" title="发表于 2023-08-15 19:42:22">2023-08-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/11/DV/UVM/UVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%91%98%E8%AE%B0/" title="UVM知识点摘记（Ch2）">UVM知识点摘记（Ch2）</a><time datetime="2023-08-11T14:02:09.000Z" title="发表于 2023-08-11 22:02:09">2023-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/09/DV/UVM/UVMDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="UVMDemo学习笔记(一个简单的UVM验证平台)">UVMDemo学习笔记(一个简单的UVM验证平台)</a><time datetime="2023-08-09T13:36:11.000Z" title="发表于 2023-08-09 21:36:11">2023-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/31/DV/Tools/Gvim%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/" title="Windows下Gvim安装与配置-续">Windows下Gvim安装与配置-续</a><time datetime="2023-07-31T09:22:18.000Z" title="发表于 2023-07-31 17:22:18">2023-07-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Guanglong Zhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>